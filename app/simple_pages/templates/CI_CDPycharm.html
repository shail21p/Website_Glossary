{% extends "base.html" %}
<article>{% block content %}
    <h1>Pycharm & CI-CD</h1>
   <body>
  <div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" data-doc-height="1" role="banner" class="navbar-dark w-nav"></div>
  <div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" data-doc-height="1" role="banner" class="navbar-light w-nav"></div>
  <div class="welcome-image-left-section wf-section">
    <div class="centered-container horizontal-flex"><img src="../../static/images/pycharm.png.png" loading="lazy" width="600" height="384" alt="" class="feature-section-image">
      <div class="feature-section-content">
        <h2 class="feature-section-heading-1">Pycharm</h2>
        <p class="paragraph">Generally, PyCharm runs and debugs tests in the same way as other applications, by running the run/debug configurations you have created. When doing so, it passes the specified test classes or methods to the test runner.

In many cases, you can initiate a testing session from a context menu. For this purpose, the Run and Debug commands are provided in certain context menus. For example, these commands are available for a test class, directory, or a package in the Project tool window. They are also available for a test class or method you are currently working on in the editor.</p>
    <h3>Files and their Representation</h3>
           <ul style="font-size:24px">
        <li><h3>Simple pages</h3></li>
            <li>Templates</li>
                <li>about: general info regarding self</li>
                <li>index: general index page</li>
                <li>Pages1-4: general data pages</li>
            <li>Dunder page</li>
        <li><h3>Static</h3></li>
            <li>Css:Basic Styling and format</li>
            <li>images:image files used in current web pages</li>
            <li>JS: JavaScript :runs basic javascript on pages</li>
        <li><h3>templates</h3></li>
            <li>base html: basic file layout to work on</li>
            <li>dunder file</li>
            <li>Run file</li>
        <li><h3>Calculator</h3></li>
            <li>Operations:basic operations for maths</li>
        <li><h3>test</h3></li>
            <li>Test pages to check for errors</li>
        <li><h3>venv</h3></li>
            <li>Flask file : creates flask</li>
            <li>Composer file : Ochestration file that contains the configuration to develop locally, it overrides the Dockerfile to run the flask development server instead of running the gunicorn server that is used for hosting on Heroku</li>
            <li>docker file: File used to create an image to run in container and runs the program</li>
            <li>Heroku.yml: Transfers the flask on heroku app so it runs via Heroku</li>
            <li>Pytest file : the .ini file is responsible for excuting pytests properly</li>
            <li>Read me and requirements</li>
            <li>Setup file</li>
    </ul>
    </ul>
    <h2>Accesing terminal using commands</h2>
    <ul style="font-size:24px">
        <li>start the command prompt or power shell</li>
        <li> docker run -d --name container name</li>
        <li>docker ps</li>
    </ul>
      </div>
    </div>
  </div>
  <div class="welcome-image-right-section wf-section">
    <div class="centered-container horizontal-flex">
      <div class="feature-section-content-2 feature-section-content-left">
        <h2 class="feature-section-heading-1">CI/CD</h2>
          <cite style="font-size:24px">Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. This article is a quick overview of Continuous Integration summarizing the technique and its current usage. ~Martin Fowler</cite>
    <h2>Practices of Continuous Integration</h2>
    <h3>Maintain a Single Source Repository.</h3>
    <p style="font-size:24px">Software projects involve lots of files that need to be orchestrated together to build a product. Keeping track of all of these is a major effort, particularly when there's multiple people involved. So it's not surprising that over the years software development teams have built tools to manage all this. These tools - called Source Code Management tools, configuration management, version control systems, repositories, or various other names - are an integral part of most development projects. The sad and surprising thing is that they aren't part of all projects. It is rare, but I do run into projects that don't use such a system and use some messy combination of local and shared drives.</p>
    <h3>Automate the Build</h3>
    <p style="font-size:24px">Getting the sources turned into a running system can often be a complicated process involving compilation, moving files around, loading schemas into the databases, and so on. However like most tasks in this part of software development it can be automated - and as a result should be automated</p>
    <h3>Make Your Build Self-Testing</h3>
    <p style="font-size:24px">A good way to catch bugs more quickly and efficiently is to include automated tests in the build process. Testing isn't perfect, of course, but it can catch a lot of bugs - enough to be useful. In particular the rise of Extreme Programming (XP) and Test Driven Development (TDD) have done a great deal to popularize self-testing code and as a result many people have seen the value of the technique.</p>
    <h2>Setting up My CI/CD</h2>
    <ul style="font-size:24px">
        <li><h4>Github Actions</h4></li>
            <li>Github actions enables you to create custom software for development lifecycle flows</li>
            <li>setup the prod.yml : change the authorization for your own heroku id/pass</li>
            <li>setup the dev.yml : change the authorization key and heroku id/pass</li>
        <li><h4>Review Code</h4></li>
        <p> using the merge pull in github you can review the code before merging pull requests in Github Pull Requests tab</p>
        <li><h4>Deploy master to a production server</h4></li>
        <p>make a test branch or feature branch, work on the branch and merge pull the branch. after the tests are done and everything works perfectly we can merge it to the main branch for deployment purposes</p>

        <li><h4>Deploy image of your project to Dockerhub when master is updated</h4></li>
        <p> use the secrets in your github settings-->actions-->secrets tab</p>
        <p>create a new secret for DockerHub username and password</p>
        <p>once that part is done docker push (docker repository name)</p>
        <p> this should allow you to integrate without your dockerhub repo</p>
    </ul>

      </div><img src="../../static/images/git_branches.png" loading="lazy" width="600" height="384" alt="" class="feature-section-image">
    </div>
  </div>
  <div class="w-container"></div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=623f6d3301c43bcf5c26cc7f" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  <!-- [if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif] -->
</body>

{% endblock %}
</article>